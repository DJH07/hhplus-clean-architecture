# 특강 신청 서비스

## 1. 요구사항 정의
### 1️⃣ 특강 신청 **API**
- 입력 값 : `userId`, `scheduleId`
- 특정 `userId`로 `scheduleId`로 특강을 신청한다
- `scheduleId`에 따른 특강 일정 정보가 존재하지 않으면 실패한다.
- 동일한 신청자는 같은 시간 동일한 특강에 대해서 한 번의 수강 신청만 성공할 수 있다.
    - 다른 시간 같은 특강을 신청할 경우 성공한다.
- 특강 시작 시간을 넘겼을 경우, 신청에 실패한다.
- 특강은 선착순 30명만 신청 가능하다. 이미 신청자가 30명이 초과 되면 이후 신청자는 요청을 실패한다.
- 신청하면 신청 정보가 저장되고, 해당 특강의 신청 인원이 1 증가한다.

### 2️⃣ **특강 신청 가능 목록 API**
- 입력 값 : `userId`, 날짜
- 날짜별로 현재 신청 가능한 특강 목록을 조회하는 API 를 작성한다.
- 특강 시작 시간을 기준으로 조회한다. 특강 종료 시간은 조회 조건에 영향을 주지 않는다.
- 특강 시작 시간을 넘겼을 경우, 조회 되지 않는다.
- 정원이 모두 찼을 경우, 조회 되지 않는다.
- `user`가 신청한 특강은 조회 되지 않는다.
- 반환할 값이 없으면 빈 배열을 반환한다.

### 3️⃣  **특강 신청 완료 목록 조회 API**
- 입력 값 : `userId`
- 특정 `userId`로 신청 완료된 특강 목록을 조회하는 API 를 작성한다.
- 각 항목은 특강 정보 `id`, 특강 일정 `id`, 특강 이름, 강연자 이름을 담고 있어야 한다.
- 신청 인원이 넘거나 시간이 지나더라도, `user`가 신청 완료한 특강 정보는 모두 조회한다.
- 특강 신청 당시 정보를 불러온다. (시간이 되면 한다.)
- 반환할 값이 없으면 빈 배열을 반환한다.

## 2. 패키지
```
application
 ├── facade
 │    └── LectureFacade.java
 └── dto

domain
 ├── 도메인
 │    ├── entity
 │    ├── service
 │    └── repository
 ├── error
 └── dto

infrastructure
 ├── repository
 │    ├── impl
 │    └── JpaRepository
 └── config

interface
 └── controller

```


## 3. ERD 설계
![image](https://github.com/user-attachments/assets/151d0cf4-ee11-42b8-a8d0-e77e53fae6e4)

- 공통 컬럼 : **created_at**, **modified_at**
  
**lecture_info** : 강의 정보 테이블
- lecture_id : 강의 정보 `id`

**lecture_schedule** : 강의 일정 정보 테이블
- schedule_id : 강의 일정 `id`
- lecture_id : 강의 정보 테이블과 연관되는 `id`
- start_dt : 강의 시작 시간. `특강 신청 API` 예외 처리 기준이자 `특강 신청 가능 목록 API` 조회 조건.
- end_dt : 강의 종료 시간. 비즈니스 로직과는 크게 연관 없다.
- apply_cnt : 강의 신청 인원수.

**lecture_apply** : 강의 신청 정보 테이블
- apply_id : 강의 신청 `id`
- user_id와 schedule_id : 복합 유니크키


### 3-1. 설계 이유
#### 3-1-1. `lecture_info` 테이블과 `lecture_schedule` 분리
- **정규화** : 중복 데이터를 최소화하여 데이터의 일관성을 유지한다. 이를 분리함으로써 강의 정보와 일정을 독립적으로 관리할 수 있다.
- **유지보수 가능성** : 현재는 특강 신청, 신청 가능한 특강 조회, 신청 완료 특강 조회가 주요 기능이지만, 향후 추가적인 기능(예: 특정 특강 일정 목록 조회, 특강 정보 일괄 수정 등)이 필요할 수 있다. 테이블을 분리해 놓으면 추후 확장에 유리하고, 각 테이블의 책임이 명확해져 유지보수가 용이하다.

#### 3-1-2. 특강 시작 시간과 종료 시간이 `datetime`인 이유
- 특강이 하루 안에 끝나지 않을 수 있기 때문에 `datetime` 타입을 사용했다. 예를 들어, 심야나 새벽 특강이 있을 수 있고, 일회성 이벤트가 아니라 일정 기간 동안 진행되는 커리큘럼 형태로 특강이 진행될 수 있기 때문에, 날짜와 시간 모두를 포함할 수 있는 `datetime`을 사용했다.
- 단, 신청 불가 조건을 특강 시작 시간으로 제한하여, 특강이 시작된 이후에는 신청을 할 수 없도록 했다. 또한, 날짜별 조회 시 기준도 특강 시작 시간을 기준으로 하여, 더 직관적이고 일관성 있는 방식으로 날짜와 시간을 처리할 수 있다.

#### 3-1-3. `lecture_schedule` 테이블에 신청 인원수를 둔 이유
- 신청 정보를 모두 `JOIN`하여 `COUNT`하는 방식보다 `lecture_schedule` 테이블에 신청 인원수를 미리 저장해두고 조회하는 게 성능 면에서 더 효율적이다. 이를 통해 조회 시 불필요한 계산을 줄일 수 있다.
- 신청 인원수가 변경될 때 `Lock`을 걸어 동시성을 제어했다.

### 3-2. 개선 확장 방안
#### 3-2-1. 강의 신청 일괄 처리 기능 (수정, 조회 등)
- **수정 기능**: 강의 신청 정보를 일괄 수정할 수 있는 기능을 제공하여, 예를 들어 일정 변경이나 신청 인원수 수정 시 편리하게 처리할 수 있다. 이를 통해 강의 정보가 변경될 때 일관성 있는 업데이트를 유지할 수 있다.
- **조회 기능**: 여러 조건에 맞는 강의 신청 정보를 일괄 조회할 수 있어, 사용자는 신청 내역을 효율적으로 확인하고, 관리자는 강의 신청 현황을 쉽게 파악할 수 있다.

#### 3-2-2. 신청정보 스냅샷 기능
- 강의 정보가 변경될 경우, 사용자가 신청할 당시의 정보를 기준으로 조회할 수 있게 저장한다. 이를 통해 강의 정보 변경 시에도 사용자는 본인이 신청한 당시의 정보를 확인할 수 있다.

## 4. 동시성 제어
### 4-1. 채택 과정
- [1주차 - 동시성 제어 방법 정리](https://github.com/hdj-hhplus/hhplus-tdd-jvm/blob/doc/step02/CONCURRENCY_DOC.md#2-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4-%EB%B0%A9%EB%B2%95)

1주차 과제에서는 `ConcurrentHashMap`과 `ReentrantLock`을 함께 사용하여 동시성을 제어했다. 하지만 이 둘은 단일 JVM 내에서만 동작한다. 
이번 과제는 `다수의 인스턴스로 어플리케이션이 동작하더라도 기능에 문제가 없도록 작성`해야 하므로, 1주차 과제에서 사용한 방안은 사용할 수 없다.

또한, `Redis`와 `Kafka`도 제한되었다. 현재 상황에서는 데이터베이스에서 제공하는 `낙관적 락`과 `비관적 락`을 사용하는 방안이 적합하다.

| **특징**           | **비관적 락**                                         | **낙관적 락**                                         |
|--------------------|------------------------------------------------------|------------------------------------------------------|
| **장점**           | - 데이터 충돌을 방지하기 위해 항상 락을 획득<br>- 데이터 무결성이 보장됨 | - 락을 최소화하여 성능이 더 우수할 수 있음<br>- 충돌이 적을 경우 더 효율적 |
| **단점**           | - 성능 저하(락을 자주 획득해야 함)<br>- 데드락 및 병목 발생 가능  | - 충돌이 많을 경우 성능 저하<br>- 락이 없을 때 오류가 발생할 수 있음 |
| **적용 상황**      | - 데이터 충돌이 자주 발생할 가능성이 높은 경우 | - 충돌이 드물거나 예측할 수 없는 경우              |

처음에는 `낙관적 락`을 고려했다. 락을 최소화하여 성능이 우수하고, 무엇보다 구현이 쉬워서 제어하기 편리하다.

그러나 충돌이 일어날 수록 오히려 성능이 떨어진다는 단점이 있다.
변경된 데이터를 커밋할 때 다른 트랜잭션과 충돌이 발생하면 롤백을 하게 된다. 충돌이 잦을 경우, 이러한 `롤백과 재시도 과정이 반복`되어 `성능 저하`를 일으킨다.

이런 단점을 고려하여 `비관적 락`을 채택했다.


### 4-2. 멀티 스레드 테스트
`동일한 사용자가 같은 정보를 5번 신청하여 동시성 문제 발생`하는 테스트를 실행하는데 아래와 같은 에러가 발생했다.

![image](https://github.com/user-attachments/assets/39327b49-00b0-4dba-8cb4-4d2e46b9d96b)

`n`번의 신청 요청 중 `n`번의 `NOT_FOUND` 에러가 발생했다.
여러 시도 끝에 (팀원님과 학습메이트님의 도움으로) 알아낸 사실로는, 멀티 스레드 테스트 시 `@Transactional`을 사용하면 문제가 발생했다.

- 관련 참고 사항
[멀티 스레드 테스트 시 초기 데이터 오류](https://ksh-coding.tistory.com/148)
